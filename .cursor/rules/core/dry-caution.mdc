---
description: Apply DRY principle carefully with Rule of Three to avoid premature abstraction
globs: []
alwaysApply: true
---

# DRY with Caution

**DRY (Don't Repeat Yourself)** is valuable, but premature DRY creates worse problems than duplication. Wait for the **Rule of Three** before abstracting.

## The Rule of Three

```
1st occurrence → Just write it
2nd occurrence → Note the duplication, keep it
3rd occurrence → NOW refactor to remove duplication
```

**Why?** The first two occurrences rarely have the same abstraction. By the third, you understand the real pattern.

## When DRY Goes Wrong

### 1. Premature Abstraction

```typescript
// ❌ Wrong DRY: Abstract too early
function processEntity<T extends BaseEntity>(
  entity: T,
  processor: EntityProcessor<T>,
  validator: EntityValidator<T>,
  options: ProcessOptions
): ProcessResult<T> {
  // Complex generic implementation
}

// ✅ Better: Keep separate until pattern is clear
function processUser(user: User): UserResult {
  // User-specific logic
}

function processOrder(order: Order): OrderResult {
  // Order-specific logic
}
```

### 2. Wrong Abstraction

```typescript
// ❌ Wrong DRY: Forcing unrelated things together
function formatDisplayValue(
  value: string | number | Date | User | Product,
  type: 'currency' | 'date' | 'user' | 'product' | 'text'
): string {
  // Complex switch with too many cases
}

// ✅ Better: Separate functions for different domains
function formatCurrency(amount: number): string
function formatDate(date: Date): string
function formatUserName(user: User): string
```

## Good DRY vs Bad DRY

### Good DRY (Abstract These)

- True utilities: `formatDate()`, `slugify()`, `debounce()`
- Business rules: Tax calculation, discount logic
- API clients: `apiClient.get()`, `apiClient.post()`
- Design tokens: Colors, spacing, typography
- Configuration: Environment variables, feature flags

### Bad DRY (Keep Duplicated)

- Similar UI components (they'll diverge based on context)
- Similar validations (business rules differ per domain)
- Similar tests (tests should be independent)
- Similar error messages (context-specific is better)

## WET Code Can Be Better

**WET = Write Everything Twice** (intentionally)

Sometimes duplication is better than the wrong abstraction

```typescript
// ✅ Acceptable duplication (different contexts)
function UserCard({ user }: Props) {
  return (
    <div className="card">
      <img src={user.avatar} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  )
}

function ProductCard({ product }: Props) {
  return (
    <div className="card">
      <img src={product.image} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
    </div>
  )
}
```

## DRY Decision Checklist

Before creating an abstraction:

- [ ] Have I seen this 3+ times?
- [ ] Is the duplication truly identical (not just similar)?
- [ ] Will changes to one always apply to others?
- [ ] Can I name the abstraction clearly?
- [ ] Will the abstraction be simpler than the duplicates?

**If any answer is NO → Keep the duplication**

## Best Practices

### Do's ✅
- Apply Rule of Three
- Keep domain logic separate
- Abstract pure utilities
- Prefer composition over inheritance
- Accept some duplication

### Don'ts ❌
- Abstract after 2 occurrences
- Create "god" utility functions
- Share code between unrelated modules
- Add parameters to "generalize"
- Force similar-looking code together

## References
- YAGNI Principle: `yagni.mdc`
- KISS Principle: `kiss-principle.mdc`
- Project conventions: `project-contexts/[project]/conventions.md`

---

**Version:** 1.3.0
**Last Updated:** 2025-12-22
