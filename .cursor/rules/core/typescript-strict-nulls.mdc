---
description: TypeScript strict null handling - explicit nullish checks, avoid truthy/falsy pitfalls
globs: []
alwaysApply: true
---

# TypeScript Strict Null Handling

**Version:** 1.1.5
**Priority:** HIGH - Prevents subtle runtime bugs
**Type:** Rule (Mandatory)

---

## Core Principle

**NEVER rely on JavaScript's truthy/falsy coercion for null checks. Always handle nullish and empty cases EXPLICITLY.**

---

## Why This Matters

JavaScript's truthy/falsy system causes subtle bugs:

```typescript
// These are ALL falsy in JavaScript:
false, 0, -0, 0n, "", '', ``, null, undefined, NaN

// Common bugs:
if (count) { ... }      // Fails when count is 0 (valid value!)
if (name) { ... }       // Fails when name is "" (valid empty string!)
if (price) { ... }      // Fails when price is 0 (free items!)
```

---

## The Rules

### 1. Use Explicit Null/Undefined Checks

```typescript
// ❌ BAD: Truthy check hides valid falsy values
if (user.name) {
  displayName(user.name);
}

// ❌ BAD: Could fail for 0, "", false
const value = data.count || defaultValue;

// ✅ GOOD: Explicit null/undefined check
if (user.name !== null && user.name !== undefined) {
  displayName(user.name);
}

// ✅ GOOD: Nullish coalescing (only null/undefined)
const value = data.count ?? defaultValue;

// ✅ GOOD: Type narrowing
if (user.name != null) {  // Checks both null AND undefined
  displayName(user.name);
}
```

### 2. Handle Empty Strings Explicitly

```typescript
// ❌ BAD: Empty string is falsy but may be valid
if (searchQuery) {
  performSearch(searchQuery);
}

// ✅ GOOD: Explicit empty check
if (searchQuery !== '') {
  performSearch(searchQuery);
}

// ✅ GOOD: Check for meaningful content
if (searchQuery.trim().length > 0) {
  performSearch(searchQuery);
}

// ✅ GOOD: Separate null and empty checks
if (searchQuery != null && searchQuery !== '') {
  performSearch(searchQuery);
}
```

### 3. Handle Zero Explicitly

```typescript
// ❌ BAD: 0 is falsy but valid
if (item.quantity) {
  updateCart(item.quantity);
}

// ❌ BAD: Shows "N/A" for quantity 0
const display = item.quantity || 'N/A';

// ✅ GOOD: Explicit check
if (item.quantity !== undefined) {
  updateCart(item.quantity);
}

// ✅ GOOD: Nullish coalescing preserves 0
const display = item.quantity ?? 'N/A';

// ✅ GOOD: Explicit type check
if (typeof item.quantity === 'number') {
  updateCart(item.quantity);
}
```

### 4. Optional Chaining with Nullish Coalescing

```typescript
// ❌ BAD: Mixing optional chaining with ||
const name = user?.profile?.name || 'Anonymous';  // "" becomes "Anonymous"

// ✅ GOOD: Use ?? with optional chaining
const name = user?.profile?.name ?? 'Anonymous';  // "" stays ""

// ✅ GOOD: Explicit fallback logic
const name = user?.profile?.name;
const displayName = name !== undefined && name !== '' ? name : 'Anonymous';
```

### 5. Array and Object Checks

```typescript
// ❌ BAD: Empty array is truthy, but might want to check length
if (items) {
  renderItems(items);
}

// ✅ GOOD: Explicit length check
if (items != null && items.length > 0) {
  renderItems(items);
}

// ✅ GOOD: Type guard for arrays
if (Array.isArray(items) && items.length > 0) {
  renderItems(items);
}

// ✅ GOOD: Object existence with property check
if (config != null && 'apiKey' in config) {
  initializeApi(config.apiKey);
}
```

### 6. Boolean Coercion

```typescript
// ❌ BAD: Implicit boolean coercion
const isEnabled = !!feature.enabled;  // 0 and "" become false

// ✅ GOOD: Explicit boolean check
const isEnabled = feature.enabled === true;

// ✅ GOOD: Strict equality for boolean
const isEnabled = feature.enabled ?? false;

// ✅ GOOD: Type assertion when type is known
const isEnabled = Boolean(feature.enabled); // OK if intentional
```

---

## React/React Native Specific

### Conditional Rendering

```tsx
// ❌ BAD: 0 renders as "0" in JSX
{count && <Badge count={count} />}

// ❌ BAD: Empty string renders nothing but confusing
{title && <Header title={title} />}

// ✅ GOOD: Explicit boolean conversion
{count > 0 && <Badge count={count} />}

// ✅ GOOD: Ternary for clarity
{count !== 0 ? <Badge count={count} /> : null}

// ✅ GOOD: Nullish check
{title != null && <Header title={title} />}

// ✅ GOOD: Boolean cast when intentional
{Boolean(items?.length) && <List items={items} />}
```

### Props with Defaults

```tsx
// ❌ BAD: Default won't apply for "" or 0
function Button({ label = 'Click' }) {
  return <button>{label || 'Click'}</button>;
}

// ✅ GOOD: Nullish coalescing
function Button({ label }: { label?: string }) {
  return <button>{label ?? 'Click'}</button>;
}

// ✅ GOOD: Explicit default in destructuring
function Counter({ count = 0 }: { count?: number }) {
  return <span>{count}</span>;  // 0 displays as "0"
}
```

---

## Vue Specific

### Template Conditionals

```vue
<!-- ❌ BAD: v-if with potential falsy values -->
<div v-if="user.score">Score: {{ user.score }}</div>

<!-- ✅ GOOD: Explicit check -->
<div v-if="user.score !== undefined">Score: {{ user.score }}</div>
<div v-if="user.score != null">Score: {{ user.score }}</div>

<!-- ✅ GOOD: Type check -->
<div v-if="typeof user.score === 'number'">Score: {{ user.score }}</div>
```

### Computed Properties

```typescript
// ❌ BAD: Truthy check
const hasDiscount = computed(() => !!product.discount);

// ✅ GOOD: Explicit check
const hasDiscount = computed(() => product.discount != null && product.discount > 0);
```

---

## ESLint Rules

Enable these ESLint rules:

```javascript
// .eslintrc.js
module.exports = {
  rules: {
    // Prefer nullish coalescing
    '@typescript-eslint/prefer-nullish-coalescing': 'error',

    // Strict boolean expressions
    '@typescript-eslint/strict-boolean-expressions': ['error', {
      allowString: false,
      allowNumber: false,
      allowNullableObject: false,
      allowNullableBoolean: false,
      allowNullableString: false,
      allowNullableNumber: false,
      allowAny: false,
    }],

    // No unnecessary condition
    '@typescript-eslint/no-unnecessary-condition': 'error',

    // Explicit function return type
    '@typescript-eslint/explicit-function-return-type': 'warn',
  }
};
```

---

## TypeScript Configuration

```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "strictNullChecks": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

---

## Quick Reference

```toon
patterns[8]{bad_pattern,good_pattern,reason}:
 if (str),if (str != null),Empty string is valid
 if (num),if (num != null),Zero is valid
 x || default,x ?? default,Preserve 0 and ""
 !!value,value === true,Explicit boolean
 {count && <X/>},{count > 0 && <X/>},0 renders in JSX
 value ? a : b,value != null ? a : b,Handle null explicitly
 arr && arr.map(),arr?.map() ?? [],Safe array operations
 obj.prop || 'default',obj.prop ?? 'default',Nullish only
```

---

## Code Review Checklist

Before approving code:

- [ ] No truthy checks on strings (could be "")
- [ ] No truthy checks on numbers (could be 0)
- [ ] Using `??` instead of `||` for defaults
- [ ] JSX conditionals use explicit boolean expressions
- [ ] Optional chaining paired with `??` not `||`
- [ ] Array `.length` checked explicitly
- [ ] TypeScript strict mode enabled

---

## References

- TypeScript Handbook: https://www.typescriptlang.org/docs/handbook/2/narrowing.html
- ESLint TypeScript: https://typescript-eslint.io/rules/strict-boolean-expressions
- React Conditional Rendering: https://react.dev/learn/conditional-rendering

---

**Version:** 1.1.5
**Last Updated:** 2025-12-15
