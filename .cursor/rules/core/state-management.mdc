---
description: Predictable state management patterns for React and Vue applications
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.vue"
alwaysApply: false
---

# State Management Rules

**Purpose:** Guidelines for predictable, maintainable state management in frontend applications

## State Categorization

| Type | Scope | Storage | Example |
|------|-------|---------|---------|
| UI State | Component | Local state | Modal open, form input |
| Client State | App-wide | Store | Theme, user preferences |
| Server State | App-wide | Query cache | API responses |
| URL State | Route | URL params | Filters, pagination |

## Choose the Right Tool

| State Type | React | Vue | When to Use |
|------------|-------|-----|-------------|
| Local UI | useState | ref/reactive | Single component |
| Shared UI | Context | provide/inject | Few components share |
| Global | Zustand/Redux | Pinia | App-wide access |
| Server | TanStack Query | TanStack Query | API data |
| Forms | React Hook Form | VeeValidate | Form handling |

## State Location Rules

```
Rule 1: Start local, lift only when needed
Rule 2: Server state ≠ Client state
Rule 3: URL is state too
Rule 4: Don't duplicate state
```

## Anti-Patterns

### Duplicating Server State
```typescript
// ❌ Bad: Copying API data to local state
const [users, setUsers] = useState([])
useEffect(() => {
  fetchUsers().then(setUsers)
}, [])

// ✅ Good: Let query library manage it
const { data: users } = useQuery(['users'], fetchUsers)
```

### Prop Drilling
```typescript
// ❌ Bad: Passing through many levels
<App user={user}>
  <Layout user={user}>
    <Header user={user}>
      <UserMenu user={user} />

// ✅ Good: Use context or store
const user = useUserStore(s => s.user)
```

### Storing Derived State
```typescript
// ❌ Bad: Storing computed values
const [items, setItems] = useState([])
const [total, setTotal] = useState(0)
useEffect(() => {
  setTotal(items.reduce((sum, i) => sum + i.price, 0))
}, [items])

// ✅ Good: Compute on render
const total = useMemo(() =>
  items.reduce((sum, i) => sum + i.price, 0),
[items])
```

## State Checklist

- [ ] State is at the right level
- [ ] Server state uses query library
- [ ] No duplicated state
- [ ] No derived state stored
- [ ] Selectors for store access
- [ ] Forms use form library
- [ ] URL state for shareable filters

## Best Practices

### Do's
- Start with local state
- Use query libraries for API data
- Derive values with useMemo/computed
- Keep stores small and focused
- Use selectors for performance

### Don'ts
- Store everything globally
- Duplicate API data locally
- Store computed values
- Subscribe to entire stores
- Mix server and client state

## References
- Project state patterns: `project-contexts/[project]/conventions.md`
- Performance rules: `performance.mdc`

---

**Version:** 1.11.0
**Last Updated:** 2026-02-13
