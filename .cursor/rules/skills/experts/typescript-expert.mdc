---
description: TypeScript/JavaScript expert - strict typing, null handling, ESLint, modern patterns
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.jsx"
alwaysApply: false
---

# TypeScript Expert Skill

**Version:** 1.1.7
**Type:** Expert Skill (Bundled Best Practices)

---

## Overview

This skill bundles all TypeScript/JavaScript best practices into a single reference. Load this skill for any TypeScript/JavaScript development.

**Bundles:**
- `typescript-strict-nulls.mdc` - Explicit null handling
- `code-quality.mdc` - General code quality
- `naming-conventions.mdc` - Naming patterns
- `use-existing-libraries.mdc` - Prefer libraries over custom utils

---

## 1. Strict Null Handling

**CRITICAL: Never rely on truthy/falsy coercion.**

```typescript
// ❌ BAD - These are ALL falsy in JavaScript:
// false, 0, -0, 0n, "", '', ``, null, undefined, NaN

if (str) { }              // "" is valid but falsy!
if (count) { }            // 0 is valid but falsy!
if (price) { }            // 0 (free) is valid but falsy!
const x = val || 'default';  // "" and 0 become 'default'!

// ✅ GOOD - Explicit checks
if (str != null) { }      // Only null/undefined
if (str !== '') { }       // Only empty string
if (count !== undefined) { }
const x = val ?? 'default';  // Nullish coalescing (null/undefined only)

// ✅ GOOD - Type guards
if (typeof count === 'number') { }
if (Array.isArray(items) && items.length > 0) { }
```

### Optional Chaining + Nullish Coalescing

```typescript
// ❌ BAD
const name = user?.profile?.name || 'Anonymous';  // "" becomes "Anonymous"

// ✅ GOOD
const name = user?.profile?.name ?? 'Anonymous';  // "" stays ""
```

---

## 2. Type Safety

### Avoid `any`

```typescript
// ❌ BAD
function process(data: any) { return data.value; }

// ✅ GOOD - Use generics or unknown
function process<T extends { value: unknown }>(data: T) { return data.value; }
function process(data: unknown) {
  if (isValidData(data)) { return data.value; }
}
```

### Use Discriminated Unions

```typescript
// ✅ GOOD - Type-safe state handling
type State =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: User[] }
  | { status: 'error'; error: Error };

function render(state: State) {
  switch (state.status) {
    case 'loading': return <Spinner />;
    case 'success': return <UserList users={state.data} />;
    case 'error': return <Error message={state.error.message} />;
    default: return null;
  }
}
```

### Const Assertions

```typescript
// ✅ GOOD - Immutable and narrowed types
const ROLES = ['admin', 'user', 'guest'] as const;
type Role = typeof ROLES[number];  // 'admin' | 'user' | 'guest'

const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
} as const;
```

### Utility Types

```typescript
// Use built-in utility types
type UserPartial = Partial<User>;           // All optional
type UserRequired = Required<User>;         // All required
type UserReadonly = Readonly<User>;         // Immutable
type UserPick = Pick<User, 'id' | 'name'>;  // Subset
type UserOmit = Omit<User, 'password'>;     // Exclude fields
type UserRecord = Record<string, User>;     // Dictionary
```

---

## 3. Modern JavaScript Patterns

### Destructuring with Defaults

```typescript
// ✅ GOOD - Safe destructuring
function greet({ name = 'Guest', age }: { name?: string; age?: number } = {}) {
  console.log(`Hello ${name}`);
}

// ✅ GOOD - Array destructuring with rest
const [first, second, ...rest] = items;
```

### Spread Operator (Immutability)

```typescript
// ✅ GOOD - Immutable updates
const updated = { ...user, name: 'New Name' };
const withNewItem = [...items, newItem];
const withoutItem = items.filter(i => i.id !== removeId);
```

### Template Literals

```typescript
// ✅ GOOD - Readable string building
const message = `Hello ${name}, you have ${count} messages`;
const multiline = `
  SELECT * FROM users
  WHERE id = ${userId}
`;  // Note: Use parameterized queries for SQL!
```

### Optional Chaining

```typescript
// ✅ GOOD - Safe property access
const city = user?.address?.city;
const firstItem = items?.[0];
const result = callback?.();
```

---

## 4. Async/Await Best Practices

### Error Handling

```typescript
// ✅ GOOD - Proper async error handling
async function fetchUser(id: string): Promise<User> {
  try {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return await response.json();
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to fetch user: ${error.message}`);
    }
    throw error;
  }
}
```

### Parallel Execution

```typescript
// ❌ BAD - Sequential (slow)
const user = await fetchUser(id);
const posts = await fetchPosts(id);

// ✅ GOOD - Parallel (fast)
const [user, posts] = await Promise.all([
  fetchUser(id),
  fetchPosts(id),
]);

// ✅ GOOD - With error handling
const results = await Promise.allSettled([
  fetchUser(id),
  fetchPosts(id),
]);
```

### AbortController for Cancellation

```typescript
// ✅ GOOD - Cancellable fetch
async function fetchWithTimeout(url: string, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, { signal: controller.signal });
    return await response.json();
  } finally {
    clearTimeout(timeoutId);
  }
}
```

---

## 5. ESLint Configuration

```javascript
// .eslintrc.js
module.exports = {
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:@typescript-eslint/recommended-requiring-type-checking',
  ],
  rules: {
    // Strict null checks
    '@typescript-eslint/prefer-nullish-coalescing': 'error',
    '@typescript-eslint/strict-boolean-expressions': 'error',
    '@typescript-eslint/no-unnecessary-condition': 'error',

    // Type safety
    '@typescript-eslint/no-explicit-any': 'error',
    '@typescript-eslint/no-unsafe-assignment': 'error',
    '@typescript-eslint/no-unsafe-member-access': 'error',
    '@typescript-eslint/no-unsafe-call': 'error',
    '@typescript-eslint/no-unsafe-return': 'error',

    // Best practices
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-floating-promises': 'error',
    '@typescript-eslint/await-thenable': 'error',
    '@typescript-eslint/no-misused-promises': 'error',

    // Code quality
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    'prefer-const': 'error',
    'no-var': 'error',
  },
};
```

---

## 6. TypeScript Configuration

```json
{
  "compilerOptions": {
    "strict": true,
    "strictNullChecks": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true
  }
}
```

---

## 7. Common Patterns

### Result Type (Error Handling)

```typescript
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchUser(id: string): Promise<Result<User>> {
  try {
    const user = await api.getUser(id);
    return { success: true, data: user };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}

// Usage
const result = await fetchUser('123');
if (result.success) {
  console.log(result.data.name);  // Type-safe!
} else {
  console.error(result.error.message);
}
```

### Builder Pattern

```typescript
class QueryBuilder {
  private query: QueryOptions = {};

  where(field: string, value: unknown): this {
    this.query.where = { ...this.query.where, [field]: value };
    return this;
  }

  orderBy(field: string, dir: 'asc' | 'desc' = 'asc'): this {
    this.query.orderBy = { field, dir };
    return this;
  }

  limit(n: number): this {
    this.query.limit = n;
    return this;
  }

  build(): QueryOptions {
    return { ...this.query };
  }
}

// Usage
const query = new QueryBuilder()
  .where('status', 'active')
  .orderBy('createdAt', 'desc')
  .limit(10)
  .build();
```

---

## 8. Code Review Checklist

- [ ] No `any` types (use `unknown` or generics)
- [ ] No truthy/falsy null checks (use explicit `!= null` or `??`)
- [ ] No `||` for defaults with possible 0 or "" (use `??`)
- [ ] Proper error handling in async functions
- [ ] Types exported for reuse
- [ ] No non-null assertions (`!`) without comment
- [ ] Discriminated unions for state management
- [ ] ESLint passing with strict rules

---

## Quick Reference

```toon
patterns[10]{bad,good,reason}:
 if (val),if (val != null),Explicit null check
 val || default,val ?? default,Preserve 0 and ""
 any,unknown or generic,Type safety
 obj!.prop,obj?.prop ?? fallback,Safe access
 try/catch ignore,Result type or rethrow,Error handling
 sequential await,Promise.all,Performance
 manual type guard,discriminated union,Type narrowing
 string concat,template literal,Readability
 var,const/let,Block scoping
 callback hell,async/await,Readability
```

---

## Related Rules

- `typescript-strict-nulls.mdc` - Detailed null handling
- `code-quality.mdc` - General quality standards
- `naming-conventions.mdc` - Naming patterns
- `use-existing-libraries.mdc` - Library preferences

---

**Version:** 1.1.7
**Last Updated:** 2025-12-17
