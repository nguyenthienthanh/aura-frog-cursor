---
description: Testing expert - TDD, unit/integration/e2e testing, mocking, coverage patterns
globs:
  - "**/*.test.ts"
  - "**/*.test.tsx"
  - "**/*.spec.ts"
  - "**/*.spec.tsx"
  - "**/test/**/*"
  - "**/__tests__/**/*"
alwaysApply: false
---

# Testing Expert Skill

**Version:** 1.1.5
**Type:** Expert Skill (Bundled Best Practices)

---

## Overview

This skill bundles all testing best practices. Load this skill for any testing work.

**Applies to:**
- Jest / Vitest
- React Testing Library
- Cypress / Playwright
- Go testing
- Python pytest

**Bundles:**
- `tdd-workflow.mdc` - TDD cycle
- `code-quality.mdc` - Quality standards

---

## 1. TDD Workflow (RED-GREEN-REFACTOR)

### The Cycle

```
1. RED    → Write a failing test first
2. GREEN  → Write minimal code to pass
3. REFACTOR → Improve code, keep tests green
4. REPEAT
```

### Example TDD Session

```typescript
// Step 1: RED - Write failing test
describe('calculateTotal', () => {
  it('should sum item prices', () => {
    const items = [{ price: 10 }, { price: 20 }];
    expect(calculateTotal(items)).toBe(30);
  });
});
// ❌ Test fails - function doesn't exist

// Step 2: GREEN - Minimal implementation
function calculateTotal(items: { price: number }[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
// ✅ Test passes

// Step 3: REFACTOR - Add more cases, improve
it('should return 0 for empty array', () => {
  expect(calculateTotal([])).toBe(0);
});

it('should handle discounts', () => {
  const items = [{ price: 100, discount: 10 }];
  expect(calculateTotal(items)).toBe(90);
});
```

---

## 2. Test Structure (AAA Pattern)

### Arrange-Act-Assert

```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user with hashed password', async () => {
      // ARRANGE - Set up test data and mocks
      const input = { email: 'test@example.com', password: 'secret123' };
      const mockHash = 'hashed_password';
      jest.spyOn(bcrypt, 'hash').mockResolvedValue(mockHash);

      // ACT - Execute the code under test
      const result = await userService.createUser(input);

      // ASSERT - Verify the outcome
      expect(result.email).toBe(input.email);
      expect(result.password).toBe(mockHash);
      expect(bcrypt.hash).toHaveBeenCalledWith(input.password, 10);
    });
  });
});
```

### Test Naming Convention

```typescript
// ✅ GOOD - Descriptive names
describe('ShoppingCart', () => {
  describe('addItem', () => {
    it('should add item to empty cart', () => {});
    it('should increase quantity if item exists', () => {});
    it('should throw error if item is out of stock', () => {});
  });

  describe('removeItem', () => {
    it('should remove item from cart', () => {});
    it('should do nothing if item not in cart', () => {});
  });
});

// Pattern: "should [expected behavior] when [condition]"
```

---

## 3. Unit Testing

### Pure Functions

```typescript
// Easy to test - no dependencies
describe('formatCurrency', () => {
  it('should format number as USD', () => {
    expect(formatCurrency(1234.5)).toBe('$1,234.50');
  });

  it('should handle zero', () => {
    expect(formatCurrency(0)).toBe('$0.00');
  });

  it('should handle negative numbers', () => {
    expect(formatCurrency(-50)).toBe('-$50.00');
  });
});
```

### Testing with Mocks

```typescript
// Mock dependencies
describe('UserController', () => {
  let controller: UserController;
  let mockUserService: jest.Mocked<UserService>;

  beforeEach(() => {
    mockUserService = {
      findById: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    } as any;

    controller = new UserController(mockUserService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return user by id', async () => {
    const mockUser = { id: '1', name: 'John' };
    mockUserService.findById.mockResolvedValue(mockUser);

    const result = await controller.getUser('1');

    expect(result).toEqual(mockUser);
    expect(mockUserService.findById).toHaveBeenCalledWith('1');
    expect(mockUserService.findById).toHaveBeenCalledTimes(1);
  });

  it('should throw NotFoundError if user not found', async () => {
    mockUserService.findById.mockResolvedValue(null);

    await expect(controller.getUser('999'))
      .rejects.toThrow(NotFoundError);
  });
});
```

### Testing Async Code

```typescript
// Async/await
it('should fetch user data', async () => {
  const user = await userService.getUser('1');
  expect(user.name).toBe('John');
});

// Promises
it('should reject with error', () => {
  return expect(userService.getUser('invalid'))
    .rejects.toThrow('User not found');
});

// Callbacks (use done)
it('should call callback with result', (done) => {
  fetchData((error, data) => {
    expect(error).toBeNull();
    expect(data).toBeDefined();
    done();
  });
});
```

---

## 4. React Component Testing

### React Testing Library

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('LoginForm', () => {
  it('should render login form', () => {
    render(<LoginForm onSubmit={jest.fn()} />);

    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /login/i })).toBeInTheDocument();
  });

  it('should call onSubmit with form data', async () => {
    const user = userEvent.setup();
    const onSubmit = jest.fn();

    render(<LoginForm onSubmit={onSubmit} />);

    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(screen.getByRole('button', { name: /login/i }));

    expect(onSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    });
  });

  it('should show validation error for invalid email', async () => {
    const user = userEvent.setup();
    render(<LoginForm onSubmit={jest.fn()} />);

    await user.type(screen.getByLabelText(/email/i), 'invalid');
    await user.click(screen.getByRole('button', { name: /login/i }));

    expect(screen.getByText(/invalid email/i)).toBeInTheDocument();
  });

  it('should show loading state while submitting', async () => {
    const user = userEvent.setup();
    const onSubmit = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

    render(<LoginForm onSubmit={onSubmit} />);

    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(screen.getByRole('button', { name: /login/i }));

    expect(screen.getByRole('button')).toBeDisabled();
    expect(screen.getByText(/loading/i)).toBeInTheDocument();

    await waitFor(() => {
      expect(screen.getByRole('button')).not.toBeDisabled();
    });
  });
});
```

### Testing Hooks

```typescript
import { renderHook, act, waitFor } from '@testing-library/react';

describe('useCounter', () => {
  it('should increment counter', () => {
    const { result } = renderHook(() => useCounter(0));

    expect(result.current.count).toBe(0);

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });
});

describe('useUser', () => {
  it('should fetch user data', async () => {
    const { result } = renderHook(() => useUser('1'));

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.user).toEqual({ id: '1', name: 'John' });
  });
});
```

### Testing with Providers

```typescript
// Custom render with providers
function renderWithProviders(
  ui: React.ReactElement,
  { initialState = {}, ...options } = {}
) {
  const store = createStore(initialState);

  function Wrapper({ children }: { children: React.ReactNode }) {
    return (
      <Provider store={store}>
        <ThemeProvider>
          <Router>
            {children}
          </Router>
        </ThemeProvider>
      </Provider>
    );
  }

  return {
    ...render(ui, { wrapper: Wrapper, ...options }),
    store,
  };
}

// Usage
it('should render with theme', () => {
  renderWithProviders(<MyComponent />);
  // ...
});
```

---

## 5. Vue Component Testing

```typescript
import { mount } from '@vue/test-utils';
import { createTestingPinia } from '@pinia/testing';

describe('UserProfile', () => {
  it('should render user name', () => {
    const wrapper = mount(UserProfile, {
      props: { userId: '1' },
      global: {
        plugins: [createTestingPinia()],
      },
    });

    expect(wrapper.text()).toContain('John');
  });

  it('should emit update event', async () => {
    const wrapper = mount(UserProfile, {
      props: { userId: '1' },
    });

    await wrapper.find('button').trigger('click');

    expect(wrapper.emitted()).toHaveProperty('update');
    expect(wrapper.emitted('update')?.[0]).toEqual([{ name: 'Updated' }]);
  });
});
```

---

## 6. Integration Testing

### API Integration Tests

```typescript
import request from 'supertest';
import { app } from '../app';
import { prisma } from '../db';

describe('POST /api/users', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  it('should create a new user', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ email: 'test@example.com', name: 'Test User' })
      .expect(201);

    expect(response.body.data).toMatchObject({
      email: 'test@example.com',
      name: 'Test User',
    });

    // Verify in database
    const user = await prisma.user.findUnique({
      where: { email: 'test@example.com' },
    });
    expect(user).not.toBeNull();
  });

  it('should return 400 for invalid email', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ email: 'invalid', name: 'Test' })
      .expect(400);

    expect(response.body.error.code).toBe('VALIDATION_ERROR');
  });

  it('should return 409 for duplicate email', async () => {
    await prisma.user.create({
      data: { email: 'test@example.com', name: 'Existing' },
    });

    await request(app)
      .post('/api/users')
      .send({ email: 'test@example.com', name: 'New' })
      .expect(409);
  });
});
```

---

## 7. E2E Testing (Playwright/Cypress)

### Playwright

```typescript
import { test, expect } from '@playwright/test';

test.describe('Login Flow', () => {
  test('should login successfully', async ({ page }) => {
    await page.goto('/login');

    await page.fill('[name="email"]', 'user@example.com');
    await page.fill('[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('h1')).toContainText('Welcome');
  });

  test('should show error for invalid credentials', async ({ page }) => {
    await page.goto('/login');

    await page.fill('[name="email"]', 'wrong@example.com');
    await page.fill('[name="password"]', 'wrong');
    await page.click('button[type="submit"]');

    await expect(page.locator('.error')).toContainText('Invalid credentials');
  });
});
```

### Cypress

```typescript
describe('Shopping Cart', () => {
  beforeEach(() => {
    cy.login('user@example.com', 'password');
    cy.visit('/products');
  });

  it('should add item to cart', () => {
    cy.get('[data-testid="product-card"]').first().click();
    cy.get('[data-testid="add-to-cart"]').click();

    cy.get('[data-testid="cart-count"]').should('contain', '1');
  });

  it('should complete checkout', () => {
    cy.addToCart('product-1');
    cy.visit('/checkout');

    cy.get('[name="cardNumber"]').type('4242424242424242');
    cy.get('[name="expiry"]').type('12/25');
    cy.get('[name="cvc"]').type('123');

    cy.get('button[type="submit"]').click();

    cy.url().should('include', '/order-confirmation');
    cy.get('h1').should('contain', 'Order Confirmed');
  });
});
```

---

## 8. Mocking Strategies

### Module Mocking

```typescript
// Mock entire module
jest.mock('../api/userApi', () => ({
  getUser: jest.fn(),
  createUser: jest.fn(),
}));

// Mock with implementation
jest.mock('../utils/date', () => ({
  getCurrentDate: () => new Date('2024-01-15'),
}));

// Partial mock
jest.mock('../services/email', () => ({
  ...jest.requireActual('../services/email'),
  sendEmail: jest.fn(),
}));
```

### Spy on Methods

```typescript
// Spy on object method
const spy = jest.spyOn(userService, 'sendEmail');
spy.mockResolvedValue({ sent: true });

await userService.createUser(data);

expect(spy).toHaveBeenCalledWith(data.email, expect.any(String));
spy.mockRestore();
```

### Mock Timers

```typescript
describe('Debounce', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('should debounce function calls', () => {
    const fn = jest.fn();
    const debounced = debounce(fn, 300);

    debounced();
    debounced();
    debounced();

    expect(fn).not.toHaveBeenCalled();

    jest.advanceTimersByTime(300);

    expect(fn).toHaveBeenCalledTimes(1);
  });
});
```

---

## 9. Coverage Guidelines

### Minimum Coverage

```
- Statements: 80%
- Branches: 80%
- Functions: 80%
- Lines: 80%
```

### What to Test

```
✅ DO test:
- Business logic
- Edge cases
- Error handling
- User interactions
- API contracts
- State changes

❌ DON'T test:
- Third-party libraries
- Simple getters/setters
- Framework code
- Implementation details
```

---

## 10. Code Review Checklist

- [ ] Tests follow AAA pattern
- [ ] Test names are descriptive
- [ ] Edge cases covered
- [ ] Error scenarios tested
- [ ] Async code properly awaited
- [ ] Mocks cleaned up after tests
- [ ] No test interdependencies
- [ ] Coverage meets threshold
- [ ] No console.log in tests
- [ ] Tests are deterministic (no flaky tests)

---

## Quick Reference

```toon
patterns[10]{scenario,tool}:
 Unit tests,Jest/Vitest
 React components,React Testing Library
 Vue components,Vue Test Utils
 E2E browser,Playwright/Cypress
 API integration,supertest
 Mocking,jest.mock/jest.spyOn
 Async testing,await/waitFor
 Time-based,jest.useFakeTimers
 Snapshot,toMatchSnapshot
 Coverage,jest --coverage
```

---

## Related Rules

- `tdd-workflow.mdc` - TDD cycle details
- `code-quality.mdc` - Quality standards

---

**Version:** 1.1.5
**Last Updated:** 2025-12-15
