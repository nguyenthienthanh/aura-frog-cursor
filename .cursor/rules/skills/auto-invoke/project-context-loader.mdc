---
description: "Load project conventions, rules, and examples BEFORE any code generation. Auto-triggers before workflow:start, implementation, code generation, or refactoring. Ensures AI follows YOUR project standards."
globs: []
alwaysApply: false
---

# Project Context Loader

**Type:** Auto-Invoke
**Trigger:** Before any code generation or workflow execution

## Purpose

Loads project-specific conventions, naming patterns, coding standards, and examples before generating any code. This ensures AI follows YOUR project's established patterns and standards rather than generic defaults.

## Activation Logic

Cursor AI should activate this skill BEFORE:
- `workflow:start` or any implementation
- Any code generation or new files
- Refactoring or writing tests
- File creation or modification

**SKIP only for:**
- Simple questions (no code involved)
- When already loaded this session

## Loading Process

### 1. Check Context Exists
```bash
if [ ! -d ".cursor/project-contexts" ]; then
  echo "⚠️ Run: project:init"
fi
```

### 2. Load Project Files

**Location:** `.cursor/project-contexts/[project]/`

```toon
project_files[4]{file,contains}:
 project-config.yaml,Tech stack/team/integrations
 conventions.md,File naming/directory structure/import aliases
 rules.md,Quality rules/testing requirements/git workflow
 examples.md,Real code examples from project
```

### 3. Load Aura Frog Core Rules
From plugin `rules/`:
- `tdd-workflow.md` - TDD methodology
- `approval-gates.md` - Workflow approval process
- `kiss-principle.md` - Simplicity rules
- `cross-review.md` - Multi-agent review process

### 4. Merge Rules (Combined, Not Replaced)
```
Final Rules = Aura Frog core rules + Project rules.md
             - ignored_rules (if specified)

Both apply together. Project wins on conflicts.
```

## Key Context Items

**Tech Stack:**
- Framework (React Native, Flutter, Next.js, etc.)
- Language (TypeScript, Python, PHP, Go)
- Styling (NativeWind, Tailwind, styled-components)
- State management (Redux, Zustand, Context)
- Testing framework (Jest, PyTest, PHPUnit)

**Linting (from project-config.yaml):**
- Linter type (eslint, tslint, biome)
- Config file location
- Critical rules to follow
- Auto-fix settings

**TypeScript (from project-config.yaml):**
- Strict mode settings
- no-any enforcement
- Non-null assertion rules

**Conventions:**
- File naming (kebab-case, PascalCase, snake_case)
- Import aliases (`@/`, `~/`, relative)
- Component structure (directory layout)
- Code organization patterns

**Rules:**
- Coverage target (default 80%, may be higher)
- Linting critical rules
- PR requirements
- Git workflow

**Examples:**
- Component patterns
- Test patterns
- API patterns
- State management patterns

## Application Examples

```toon
context_examples[5]{without_context,with_context}:
 userProfile.tsx,UserProfile.tsx (PascalCase)
 StyleSheet.create,NativeWind className
 80% coverage,85% coverage (project rule)
 Relative imports,@/components/Button
 Generic component,Project-specific pattern
```

## Context Usage

### During Code Generation
```typescript
// Generic (without context):
import Button from '../../../components/Button';

// Project-specific (with context loaded):
import { Button } from '@/components/ui';
```

### During Testing
```typescript
// Generic (without context):
describe('User', () => {
  // 80% coverage default
});

// Project-specific (with context loaded):
describe('User', () => {
  // 85% coverage per project rules
  // Uses project-specific test helpers
});
```

## If Context Missing

```markdown
⚠️ **Project context not found!**

Run: `project:init`

This will create:
- .cursor/project-contexts/[project]/project-config.yaml
- .cursor/project-contexts/[project]/conventions.md
- .cursor/project-contexts/[project]/rules.md
- .cursor/project-contexts/[project]/examples.md

Continue with Aura Frog defaults? [yes/no]
```

## Context Files Structure

### project-config.toon
```toon
project{name,type}:
 my-app,react-native

stack[5]{key,value}:
 framework,react-native
 language,typescript
 styling,nativewind
 state,zustand
 testing,jest

agents{primary,secondary}:
 mobile-react-native,qa-automation|ui-designer

integrations[3]{name,enabled}:
 jira,true
 figma,true
 slack,true
```

### conventions.toon
```toon
naming[3]{type,pattern,example}:
 components,PascalCase,Button.tsx
 utilities,camelCase,formatDate.ts
 tests,*.test.ts,Button.test.ts

aliases[2]{alias,path}:
 @/components,src/components
 @/utils,src/utils

structure{base,dirs}:
 src/,components/ui|components/features|utils|hooks
```

### rules.toon
```toon
quality[4]{rule,value}:
 coverage,85%
 console,no-production
 testid,required
 typescript,strict

git{branch_from,pr_approvals,tests}:
 main,1,required
```

### examples.toon
```toon
patterns[1]{type,file}:
 component,examples/Button.tsx
```

---

## Session Context Generation

**Output:** `.cursor/aura-frog/session-context.toon`

This skill generates a session context file that tracks:
- Current workflow state
- Architectural decisions made
- Established patterns

### Generated Format
```toon
state{phase,feature,started}:
 implementation,User Auth,2025-12-16T10:00

decisions[N]{id,choice,reason}:
 1,JWT tokens,Stateless + scalable
 2,bcrypt,Industry standard

patterns[N]{type,convention,example}:
 naming,camelCase functions,getUserById
 naming,PascalCase components,UserProfile
 imports,absolute paths,@/components/Button
 structure,feature folders,src/features/auth/
```

### Linked Rule
See **`codebase-consistency.mdc`** - Ensures Claude reads session-context.toon before code generation.

## Loading Indicators

When context is loaded:
```
✅ Project context loaded: my-app
   - Tech: React Native + TypeScript + NativeWind
   - Coverage target: 85%
   - Session context: .cursor/aura-frog/session-context.toon
```

When context not found:
```
⚠️ No project context found
   Using Aura Frog defaults
```

## Integration

Works seamlessly with:
- `workflow-orchestrator` - Loads context before Phase 2 (Design)
- `agent-detector` - Uses project-config.toon for agent priorities
- `test-writer` - Uses coverage targets and test patterns
- `code-reviewer` - Uses quality rules for review criteria
- `codebase-consistency` - Ensures patterns are followed
- All code generation skills - Ensures correct patterns

## Benefits

1. **Consistency** - All generated code follows project patterns
2. **Quality** - Enforces project-specific quality rules
3. **Speed** - No need to explain conventions each time
4. **Standards** - Maintains codebase standards automatically
5. **Onboarding** - New developers get instant context
6. **Token Efficiency** - TOON format reduces tokens by ~73%

## References

- Project contexts: `.cursor/project-contexts/`
- Session context: `.cursor/aura-frog/session-context.toon`
- Consistency rule: `codebase-consistency.mdc`
- Context initialization: `project:init` command

---

**Version:** 1.2.0
**Last Updated:** 2025-12-17
